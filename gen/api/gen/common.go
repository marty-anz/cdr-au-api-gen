// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// Defines values for CommonEmailAddressPurpose.
const (
	CommonEmailAddressPurposeHOME        CommonEmailAddressPurpose = "HOME"
	CommonEmailAddressPurposeOTHER       CommonEmailAddressPurpose = "OTHER"
	CommonEmailAddressPurposeUNSPECIFIED CommonEmailAddressPurpose = "UNSPECIFIED"
	CommonEmailAddressPurposeWORK        CommonEmailAddressPurpose = "WORK"
)

// Defines values for CommonOrganisationIndustryCodeVersion.
const (
	CommonOrganisationIndustryCodeVersionANZSIC129202006V10 CommonOrganisationIndustryCodeVersion = "ANZSIC_1292.0_2006_V1.0"
	CommonOrganisationIndustryCodeVersionANZSIC129202006V20 CommonOrganisationIndustryCodeVersion = "ANZSIC_1292.0_2006_V2.0"
)

// Defines values for CommonOrganisationOrganisationType.
const (
	CommonOrganisationOrganisationTypeCOMPANY          CommonOrganisationOrganisationType = "COMPANY"
	CommonOrganisationOrganisationTypeGOVERNMENTENTITY CommonOrganisationOrganisationType = "GOVERNMENT_ENTITY"
	CommonOrganisationOrganisationTypeOTHER            CommonOrganisationOrganisationType = "OTHER"
	CommonOrganisationOrganisationTypePARTNERSHIP      CommonOrganisationOrganisationType = "PARTNERSHIP"
	CommonOrganisationOrganisationTypeSOLETRADER       CommonOrganisationOrganisationType = "SOLE_TRADER"
	CommonOrganisationOrganisationTypeTRUST            CommonOrganisationOrganisationType = "TRUST"
)

// Defines values for CommonOrganisationDetailV2IndustryCodeVersion.
const (
	CommonOrganisationDetailV2IndustryCodeVersionANZSIC129202006V10 CommonOrganisationDetailV2IndustryCodeVersion = "ANZSIC_1292.0_2006_V1.0"
	CommonOrganisationDetailV2IndustryCodeVersionANZSIC129202006V20 CommonOrganisationDetailV2IndustryCodeVersion = "ANZSIC_1292.0_2006_V2.0"
)

// Defines values for CommonOrganisationDetailV2OrganisationType.
const (
	CommonOrganisationDetailV2OrganisationTypeCOMPANY          CommonOrganisationDetailV2OrganisationType = "COMPANY"
	CommonOrganisationDetailV2OrganisationTypeGOVERNMENTENTITY CommonOrganisationDetailV2OrganisationType = "GOVERNMENT_ENTITY"
	CommonOrganisationDetailV2OrganisationTypeOTHER            CommonOrganisationDetailV2OrganisationType = "OTHER"
	CommonOrganisationDetailV2OrganisationTypePARTNERSHIP      CommonOrganisationDetailV2OrganisationType = "PARTNERSHIP"
	CommonOrganisationDetailV2OrganisationTypeSOLETRADER       CommonOrganisationDetailV2OrganisationType = "SOLE_TRADER"
	CommonOrganisationDetailV2OrganisationTypeTRUST            CommonOrganisationDetailV2OrganisationType = "TRUST"
)

// Defines values for CommonPersonOccupationCodeVersion.
const (
	CommonPersonOccupationCodeVersionANZSCO122002006V10 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2006_V1.0"
	CommonPersonOccupationCodeVersionANZSCO122002006V11 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2006_V1.1"
	CommonPersonOccupationCodeVersionANZSCO122002013V12 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2013_V1.2"
	CommonPersonOccupationCodeVersionANZSCO122002013V13 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2013_V1.3"
)

// Defines values for CommonPersonDetailV2OccupationCodeVersion.
const (
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002006V10 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2006_V1.0"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002006V11 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2006_V1.1"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002013V12 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2013_V1.2"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002013V13 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2013_V1.3"
)

// Defines values for CommonPhoneNumberPurpose.
const (
	CommonPhoneNumberPurposeHOME          CommonPhoneNumberPurpose = "HOME"
	CommonPhoneNumberPurposeINTERNATIONAL CommonPhoneNumberPurpose = "INTERNATIONAL"
	CommonPhoneNumberPurposeMOBILE        CommonPhoneNumberPurpose = "MOBILE"
	CommonPhoneNumberPurposeOTHER         CommonPhoneNumberPurpose = "OTHER"
	CommonPhoneNumberPurposeUNSPECIFIED   CommonPhoneNumberPurpose = "UNSPECIFIED"
	CommonPhoneNumberPurposeWORK          CommonPhoneNumberPurpose = "WORK"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	CommonPhysicalAddressAddressUTypePaf    CommonPhysicalAddressAddressUType = "paf"
	CommonPhysicalAddressAddressUTypeSimple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for CommonPhysicalAddressWithPurposeAddressUType.
const (
	CommonPhysicalAddressWithPurposeAddressUTypePaf    CommonPhysicalAddressWithPurposeAddressUType = "paf"
	CommonPhysicalAddressWithPurposeAddressUTypeSimple CommonPhysicalAddressWithPurposeAddressUType = "simple"
)

// Defines values for CommonPhysicalAddressWithPurposePurpose.
const (
	MAIL       CommonPhysicalAddressWithPurposePurpose = "MAIL"
	OTHER      CommonPhysicalAddressWithPurposePurpose = "OTHER"
	PHYSICAL   CommonPhysicalAddressWithPurposePurpose = "PHYSICAL"
	REGISTERED CommonPhysicalAddressWithPurposePurpose = "REGISTERED"
	WORK       CommonPhysicalAddressWithPurposePurpose = "WORK"
)

// Defines values for ResponseCommonCustomerDataCustomerUType.
const (
	ResponseCommonCustomerDataCustomerUTypeOrganisation ResponseCommonCustomerDataCustomerUType = "organisation"
	ResponseCommonCustomerDataCustomerUTypePerson       ResponseCommonCustomerDataCustomerUType = "person"
)

// Defines values for ResponseCommonCustomerDetailV2DataCustomerUType.
const (
	ResponseCommonCustomerDetailV2DataCustomerUTypeOrganisation ResponseCommonCustomerDetailV2DataCustomerUType = "organisation"
	ResponseCommonCustomerDetailV2DataCustomerUTypePerson       ResponseCommonCustomerDetailV2DataCustomerUType = "person"
)

// Defines values for ResponseCommonDiscoveryStatusDataStatus.
const (
	OK              ResponseCommonDiscoveryStatusDataStatus = "OK"
	PARTIALFAILURE  ResponseCommonDiscoveryStatusDataStatus = "PARTIAL_FAILURE"
	SCHEDULEDOUTAGE ResponseCommonDiscoveryStatusDataStatus = "SCHEDULED_OUTAGE"
	UNAVAILABLE     ResponseCommonDiscoveryStatusDataStatus = "UNAVAILABLE"
)

// CommonEmailAddress defines model for CommonEmailAddress.
type CommonEmailAddress struct {
	// Address A correctly formatted email address, as defined by the addr-spec format in **[[RFC5322]](#nref-RFC5322)**
	Address string `json:"address"`

	// IsPreferred May be true for one and only one email record in the collection. Denotes the default email address
	IsPreferred *bool `json:"isPreferred,omitempty"`

	// Purpose The purpose for the email, as specified by the customer (Enumeration)
	Purpose CommonEmailAddressPurpose `json:"purpose"`
}

// CommonEmailAddressPurpose The purpose for the email, as specified by the customer (Enumeration)
type CommonEmailAddressPurpose string

// CommonOrganisation defines model for CommonOrganisation.
type CommonOrganisation struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
	Acn *string `json:"acn,omitempty"`

	// AgentFirstName The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
	AgentFirstName *string `json:"agentFirstName,omitempty"`

	// AgentLastName The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
	AgentLastName string `json:"agentLastName"`

	// AgentRole The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
	AgentRole string `json:"agentRole"`

	// BusinessName Name of the organisation
	BusinessName string `json:"businessName"`

	// EstablishmentDate The date the organisation described was established
	EstablishmentDate *string `json:"establishmentDate,omitempty"`

	// IndustryCode A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
	IndustryCode *string `json:"industryCode,omitempty"`

	// IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
	IndustryCodeVersion *CommonOrganisationIndustryCodeVersion `json:"industryCodeVersion,omitempty"`

	// IsACNCRegistered True if registered with the ACNC.  False if not. Absent or null if not confirmed.
	IsACNCRegistered *bool `json:"isACNCRegistered,omitempty"`

	// LastUpdateTime The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// LegalName Legal name, if different to the business name
	LegalName *string `json:"legalName,omitempty"`

	// OrganisationType Legal organisation type
	OrganisationType CommonOrganisationOrganisationType `json:"organisationType"`

	// RegisteredCountry Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// ShortName Short name used for communication, if different to the business name
	ShortName *string `json:"shortName,omitempty"`
}

// CommonOrganisationIndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if “industryCode“ is also supplied. If “industryCode“ is supplied but “industryCodeVersion“ is absent, default is “ANZSIC_1292.0_2006_V2.0“
type CommonOrganisationIndustryCodeVersion string

// CommonOrganisationOrganisationType Legal organisation type
type CommonOrganisationOrganisationType string

// CommonOrganisationDetailV2 defines model for CommonOrganisationDetailV2.
type CommonOrganisationDetailV2 struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
	Acn *string `json:"acn,omitempty"`

	// AgentFirstName The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
	AgentFirstName *string `json:"agentFirstName,omitempty"`

	// AgentLastName The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
	AgentLastName string `json:"agentLastName"`

	// AgentRole The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
	AgentRole string `json:"agentRole"`

	// BusinessName Name of the organisation
	BusinessName string `json:"businessName"`

	// EstablishmentDate The date the organisation described was established
	EstablishmentDate *string `json:"establishmentDate,omitempty"`

	// IndustryCode A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
	IndustryCode *string `json:"industryCode,omitempty"`

	// IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
	IndustryCodeVersion *CommonOrganisationDetailV2IndustryCodeVersion `json:"industryCodeVersion,omitempty"`

	// IsACNCRegistered True if registered with the ACNC.  False if not. Absent or null if not confirmed.
	IsACNCRegistered *bool `json:"isACNCRegistered,omitempty"`

	// LastUpdateTime The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// LegalName Legal name, if different to the business name
	LegalName *string `json:"legalName,omitempty"`

	// OrganisationType Legal organisation type
	OrganisationType CommonOrganisationDetailV2OrganisationType `json:"organisationType"`

	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`

	// RegisteredCountry Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// ShortName Short name used for communication, if different to the business name
	ShortName *string `json:"shortName,omitempty"`
}

// CommonOrganisationDetailV2IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if “industryCode“ is also supplied. If “industryCode“ is supplied but “industryCodeVersion“ is absent, default is “ANZSIC_1292.0_2006_V2.0“
type CommonOrganisationDetailV2IndustryCodeVersion string

// CommonOrganisationDetailV2OrganisationType Legal organisation type
type CommonOrganisationDetailV2OrganisationType string

// CommonPAFAddress Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
type CommonPAFAddress struct {
	// BuildingName1 Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// BuildingName2 Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Dpid Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// FlatUnitNumber Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// FlatUnitType Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// FloorLevelNumber Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// FloorLevelType Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// LocalityName Full name of locality
	LocalityName string `json:"localityName"`

	// LotNumber Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// PostalDeliveryNumber Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// PostalDeliveryNumberPrefix Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// PostalDeliveryNumberSuffix Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// PostalDeliveryType Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode Postcode for the locality
	Postcode string `json:"postcode"`

	// State State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// StreetName The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// StreetSuffix The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// StreetType The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// ThoroughfareNumber1 Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// ThoroughfareNumber1Suffix Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// ThoroughfareNumber2 Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// ThoroughfareNumber2Suffix Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPerson defines model for CommonPerson.
type CommonPerson struct {
	// FirstName For people with single names this field need not be present. The single name should be in the lastName field. Where a data holder cannot determine first and middle names from a collection of given names, a single string representing all given names MAY be provided.
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// LastUpdateTime The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames []string `json:"middleNames"`

	// OccupationCode Value is a valid **[[ANZSCO]](#iref-ANZSCO)** Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported **[[ANZSCO]](#iref-ANZSCO)** versions, then it must not be supplied.
	OccupationCode *string `json:"occupationCode,omitempty"`

	// OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
	OccupationCodeVersion *CommonPersonOccupationCodeVersion `json:"occupationCodeVersion,omitempty"`

	// Prefix Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// CommonPersonOccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an “occupationCode“ is supplied. If “occupationCode“ is supplied but “occupationCodeVersion“ is absent, default is “ANZSCO_1220.0_2013_V1.2“
type CommonPersonOccupationCodeVersion string

// CommonPersonDetailV2 defines model for CommonPersonDetailV2.
type CommonPersonDetailV2 struct {
	// EmailAddresses May be empty
	EmailAddresses []CommonEmailAddress `json:"emailAddresses"`

	// FirstName For people with single names this field need not be present. The single name should be in the lastName field. Where a data holder cannot determine first and middle names from a collection of given names, a single string representing all given names MAY be provided.
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// LastUpdateTime The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames []string `json:"middleNames"`

	// OccupationCode Value is a valid **[[ANZSCO]](#iref-ANZSCO)** Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported **[[ANZSCO]](#iref-ANZSCO)** versions, then it must not be supplied.
	OccupationCode *string `json:"occupationCode,omitempty"`

	// OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
	OccupationCodeVersion *CommonPersonDetailV2OccupationCodeVersion `json:"occupationCodeVersion,omitempty"`

	// PhoneNumbers Array is mandatory but may be empty if no phone numbers are held
	PhoneNumbers []CommonPhoneNumber `json:"phoneNumbers"`

	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`

	// Prefix Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// CommonPersonDetailV2OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an “occupationCode“ is supplied. If “occupationCode“ is supplied but “occupationCodeVersion“ is absent, default is “ANZSCO_1220.0_2013_V1.2“
type CommonPersonDetailV2OccupationCodeVersion string

// CommonPhoneNumber defines model for CommonPhoneNumber.
type CommonPhoneNumber struct {
	// AreaCode Required for non Mobile Phones, if field is present and refers to Australian code - the leading 0 should be omitted.
	AreaCode *string `json:"areaCode,omitempty"`

	// CountryCode If absent, assumed to be Australia (+61). The + should be included
	CountryCode *string `json:"countryCode,omitempty"`

	// Extension An extension number (if applicable)
	Extension *string `json:"extension,omitempty"`

	// FullNumber Fully formatted phone number with country code, area code, number and extension incorporated. Formatted according to section 5.1.4. of **[[RFC3966]](#iref-RFC3966)**
	FullNumber string `json:"fullNumber"`

	// IsPreferred May be true for one and only one entry to indicate the preferred phone number. Assumed to be 'false' if not present
	IsPreferred *bool `json:"isPreferred,omitempty"`

	// Number The actual phone number, with leading zeros as appropriate
	Number string `json:"number"`

	// Purpose The purpose of the number as specified by the customer
	Purpose CommonPhoneNumberPurpose `json:"purpose"`
}

// CommonPhoneNumberPurpose The purpose of the number as specified by the customer
type CommonPhoneNumberPurpose string

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
	Paf    *CommonPAFAddress    `json:"paf,omitempty"`
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// CommonPhysicalAddressAddressUType The type of address object present
type CommonPhysicalAddressAddressUType string

// CommonPhysicalAddressWithPurpose defines model for CommonPhysicalAddressWithPurpose.
type CommonPhysicalAddressWithPurpose struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressWithPurposeAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
	Paf *CommonPAFAddress `json:"paf,omitempty"`

	// Purpose Enumeration of values indicating the purpose of the physical address
	Purpose CommonPhysicalAddressWithPurposePurpose `json:"purpose"`
	Simple  *CommonSimpleAddress                    `json:"simple,omitempty"`
}

// CommonPhysicalAddressWithPurposeAddressUType The type of address object present
type CommonPhysicalAddressWithPurposeAddressUType string

// CommonPhysicalAddressWithPurposePurpose Enumeration of values indicating the purpose of the physical address
type CommonPhysicalAddressWithPurposePurpose string

// CommonSimpleAddress defines model for CommonSimpleAddress.
type CommonSimpleAddress struct {
	// AddressLine1 First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Name of the city or locality
	City string `json:"city"`

	// Country A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// MailingName Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Postcode Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// State Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// DiscoveryOutage defines model for DiscoveryOutage.
type DiscoveryOutage struct {
	// Duration Planned duration of the outage. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	Duration string `json:"duration"`

	// Explanation Provides an explanation of the current outage that can be displayed to an end customer
	Explanation string `json:"explanation"`

	// IsPartial Flag that indicates, if present and set to true, that the outage is only partial meaning that only a subset of normally available end points will be affected by the outage
	IsPartial *bool `json:"isPartial,omitempty"`

	// OutageTime Date and time that the outage is scheduled to begin
	OutageTime string `json:"outageTime"`
}

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaError Additional data for customised error codes
type MetaError struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// ResponseCommonCustomer defines model for ResponseCommonCustomer.
type ResponseCommonCustomer struct {
	Data struct {
		// CustomerUType The type of customer object that is present
		CustomerUType ResponseCommonCustomerDataCustomerUType `json:"customerUType"`
		Organisation  *CommonOrganisation                     `json:"organisation,omitempty"`
		Person        *CommonPerson                           `json:"person,omitempty"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  *Meta `json:"meta,omitempty"`
}

// ResponseCommonCustomerDataCustomerUType The type of customer object that is present
type ResponseCommonCustomerDataCustomerUType string

// ResponseCommonCustomerDetailV2 defines model for ResponseCommonCustomerDetailV2.
type ResponseCommonCustomerDetailV2 struct {
	Data struct {
		// CustomerUType The type of customer object that is present
		CustomerUType ResponseCommonCustomerDetailV2DataCustomerUType `json:"customerUType"`
		Organisation  *CommonOrganisationDetailV2                     `json:"organisation,omitempty"`
		Person        *CommonPersonDetailV2                           `json:"person,omitempty"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  *Meta `json:"meta,omitempty"`
}

// ResponseCommonCustomerDetailV2DataCustomerUType The type of customer object that is present
type ResponseCommonCustomerDetailV2DataCustomerUType string

// ResponseCommonDiscoveryStatus defines model for ResponseCommonDiscoveryStatus.
type ResponseCommonDiscoveryStatus struct {
	Data struct {
		// DetectionTime The date and time that the current outage was detected. Should only be present if the status property is PARTIAL_FAILURE or UNAVAILABLE
		DetectionTime *string `json:"detectionTime,omitempty"`

		// ExpectedResolutionTime The date and time that full service is expected to resume (if known). Should not be present if the status property has a value of OK.
		ExpectedResolutionTime *string `json:"expectedResolutionTime,omitempty"`

		// Explanation Provides an explanation of the current outage that can be displayed to an end customer. Mandatory if the status property is any value other than OK
		Explanation *string `json:"explanation,omitempty"`

		// Status Enumeration with values. OK (implementation is fully functional). PARTIAL_FAILURE (one or more end points are unexpectedly unavailable). UNAVAILABLE (the full implementation is unexpectedly unavailable). SCHEDULED_OUTAGE (an advertised outage is in effect)
		Status ResponseCommonDiscoveryStatusDataStatus `json:"status"`

		// UpdateTime The date and time that this status was last updated by the Data Holder.
		UpdateTime string `json:"updateTime"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  *Meta `json:"meta,omitempty"`
}

// ResponseCommonDiscoveryStatusDataStatus Enumeration with values. OK (implementation is fully functional). PARTIAL_FAILURE (one or more end points are unexpectedly unavailable). UNAVAILABLE (the full implementation is unexpectedly unavailable). SCHEDULED_OUTAGE (an advertised outage is in effect)
type ResponseCommonDiscoveryStatusDataStatus string

// ResponseDiscoveryOutagesList defines model for ResponseDiscoveryOutagesList.
type ResponseDiscoveryOutagesList struct {
	Data struct {
		// Outages List of scheduled outages. Property is mandatory but may contain and empty list if no outages are scheduled
		Outages []DiscoveryOutage `json:"outages"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  *Meta `json:"meta,omitempty"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []struct {
		// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
		Code string `json:"code"`

		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Meta Additional data for customised error codes
		Meta *MetaError `json:"meta,omitempty"`

		// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
		Title string `json:"title"`
	} `json:"errors"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-1.0-Baseline]](#nref-FAPI-1-0-Baseline)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetCustomerDetailParams defines parameters for GetCustomerDetail.
type GetCustomerDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-1.0-Baseline]](#nref-FAPI-1-0-Baseline)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetOutagesParams defines parameters for GetOutages.
type GetOutagesParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// GetStatusParams defines parameters for GetStatus.
type GetStatusParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCustomer request
	GetCustomer(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerDetail request
	GetCustomerDetail(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutages request
	GetOutages(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCustomer(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerDetail(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerDetailRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutages(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, params *GetCustomerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/common/customer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetCustomerDetailRequest generates requests for GetCustomerDetail
func NewGetCustomerDetailRequest(server string, params *GetCustomerDetailParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/common/customer/detail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetOutagesRequest generates requests for GetOutages
func NewGetOutagesRequest(server string, params *GetOutagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/outages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string, params *GetStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCustomerWithResponse request
	GetCustomerWithResponse(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// GetCustomerDetailWithResponse request
	GetCustomerDetailWithResponse(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*GetCustomerDetailResponse, error)

	// GetOutagesWithResponse request
	GetOutagesWithResponse(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*GetOutagesResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)
}

type GetCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonCustomer
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonCustomerDetailV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetCustomerDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseDiscoveryOutagesList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetOutagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonDiscoveryStatus
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// GetCustomerDetailWithResponse request returning *GetCustomerDetailResponse
func (c *ClientWithResponses) GetCustomerDetailWithResponse(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*GetCustomerDetailResponse, error) {
	rsp, err := c.GetCustomerDetail(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerDetailResponse(rsp)
}

// GetOutagesWithResponse request returning *GetOutagesResponse
func (c *ClientWithResponses) GetOutagesWithResponse(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*GetOutagesResponse, error) {
	rsp, err := c.GetOutages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutagesResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetCustomerDetailResponse parses an HTTP response from a GetCustomerDetailWithResponse call
func ParseGetCustomerDetailResponse(rsp *http.Response) (*GetCustomerDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonCustomerDetailV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetOutagesResponse parses an HTTP response from a GetOutagesWithResponse call
func ParseGetOutagesResponse(rsp *http.Response) (*GetOutagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseDiscoveryOutagesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonDiscoveryStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Customer
	// (GET /common/customer)
	GetCustomer(w http.ResponseWriter, r *http.Request, params GetCustomerParams)
	// Get Customer Detail
	// (GET /common/customer/detail)
	GetCustomerDetail(w http.ResponseWriter, r *http.Request, params GetCustomerDetailParams)
	// Get Outages
	// (GET /discovery/outages)
	GetOutages(w http.ResponseWriter, r *http.Request, params GetOutagesParams)
	// Get Status
	// (GET /discovery/status)
	GetStatus(w http.ResponseWriter, r *http.Request, params GetStatusParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get Customer
// (GET /common/customer)
func (_ Unimplemented) GetCustomer(w http.ResponseWriter, r *http.Request, params GetCustomerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Customer Detail
// (GET /common/customer/detail)
func (_ Unimplemented) GetCustomerDetail(w http.ResponseWriter, r *http.Request, params GetCustomerDetailParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Outages
// (GET /discovery/outages)
func (_ Unimplemented) GetOutages(w http.ResponseWriter, r *http.Request, params GetOutagesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Status
// (GET /discovery/status)
func (_ Unimplemented) GetStatus(w http.ResponseWriter, r *http.Request, params GetStatusParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetCustomer operation middleware
func (siw *ServerInterfaceWrapper) GetCustomer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerParams

	headers := r.Header

	// ------------- Required header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-v", valueList[0], &XV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-v", Err: err})
			return
		}

		params.XV = XV

	} else {
		err := fmt.Errorf("Header parameter x-v is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-v", Err: err})
		return
	}

	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-min-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-min-v", valueList[0], &XMinV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-min-v", Err: err})
			return
		}

		params.XMinV = &XMinV

	}

	// ------------- Optional header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionId = &XFapiInteractionId

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIpAddress string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIpAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIpAddress = &XFapiCustomerIpAddress

	}

	// ------------- Optional header parameter "x-cds-client-headers" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-cds-client-headers")]; found {
		var XCdsClientHeaders string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-cds-client-headers", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-cds-client-headers", valueList[0], &XCdsClientHeaders, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-cds-client-headers", Err: err})
			return
		}

		params.XCdsClientHeaders = &XCdsClientHeaders

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCustomer(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCustomerDetail operation middleware
func (siw *ServerInterfaceWrapper) GetCustomerDetail(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomerDetailParams

	headers := r.Header

	// ------------- Required header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-v", valueList[0], &XV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-v", Err: err})
			return
		}

		params.XV = XV

	} else {
		err := fmt.Errorf("Header parameter x-v is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-v", Err: err})
		return
	}

	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-min-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-min-v", valueList[0], &XMinV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-min-v", Err: err})
			return
		}

		params.XMinV = &XMinV

	}

	// ------------- Optional header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionId = &XFapiInteractionId

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIpAddress string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIpAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIpAddress = &XFapiCustomerIpAddress

	}

	// ------------- Optional header parameter "x-cds-client-headers" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-cds-client-headers")]; found {
		var XCdsClientHeaders string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-cds-client-headers", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-cds-client-headers", valueList[0], &XCdsClientHeaders, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-cds-client-headers", Err: err})
			return
		}

		params.XCdsClientHeaders = &XCdsClientHeaders

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCustomerDetail(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetOutages operation middleware
func (siw *ServerInterfaceWrapper) GetOutages(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOutagesParams

	headers := r.Header

	// ------------- Required header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-v", valueList[0], &XV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-v", Err: err})
			return
		}

		params.XV = XV

	} else {
		err := fmt.Errorf("Header parameter x-v is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-v", Err: err})
		return
	}

	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-min-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-min-v", valueList[0], &XMinV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-min-v", Err: err})
			return
		}

		params.XMinV = &XMinV

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOutages(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetStatus operation middleware
func (siw *ServerInterfaceWrapper) GetStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStatusParams

	headers := r.Header

	// ------------- Required header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-v", valueList[0], &XV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-v", Err: err})
			return
		}

		params.XV = XV

	} else {
		err := fmt.Errorf("Header parameter x-v is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-v", Err: err})
		return
	}

	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-min-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-min-v", valueList[0], &XMinV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-min-v", Err: err})
			return
		}

		params.XMinV = &XMinV

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStatus(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/common/customer", wrapper.GetCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/common/customer/detail", wrapper.GetCustomerDetail)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/discovery/outages", wrapper.GetOutages)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/discovery/status", wrapper.GetStatus)
	})

	return r
}
